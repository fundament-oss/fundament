// Code generator for authz types from OpenFGA model.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strings"
	"text/template"
	"unicode"
)

type Model struct {
	Types   []Type
	Actions []string // deduplicated actions across all types
}

type Type struct {
	Name      string
	Relations []string
}

func main() {
	input := flag.String("input", "", "path to OpenFGA model file")
	output := flag.String("output", "", "path to output Go file")
	flag.Parse()

	if *input == "" || *output == "" {
		fmt.Fprintln(os.Stderr, "usage: go run main.go -input model.fga -output types_gen.go")
		os.Exit(1)
	}

	model, err := parseModel(*input)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse model: %v\n", err)
		os.Exit(1)
	}

	if err := generateCode(model, *output); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate code: %v\n", err)
		os.Exit(1)
	}
}

func parseModel(path string) (*Model, error) {
	f, err := os.Open(path) //nolint:gosec // path comes from command-line flag
	if err != nil {
		return nil, fmt.Errorf("open model file: %w", err)
	}
	defer f.Close() //nolint:errcheck // read-only file

	model := &Model{}
	var currentType *Type

	relationRe := regexp.MustCompile(`^\s+define\s+(\w+):`)

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()

		if after, ok := strings.CutPrefix(line, "type "); ok {
			name := after
			name = strings.TrimSpace(name)
			currentType = &Type{Name: name}
			model.Types = append(model.Types, *currentType)
			currentType = &model.Types[len(model.Types)-1]
			continue
		}

		if currentType != nil {
			if matches := relationRe.FindStringSubmatch(line); matches != nil {
				currentType.Relations = append(currentType.Relations, matches[1])
			}
		}
	}

	// Deduplicate actions across all types
	seen := make(map[string]bool)
	for _, t := range model.Types {
		for _, r := range t.Relations {
			if !seen[r] {
				seen[r] = true
				model.Actions = append(model.Actions, r)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("scan model file: %w", err)
	}
	return model, nil
}

func generateCode(model *Model, path string) error {
	f, err := os.Create(path) //nolint:gosec // path comes from command-line flag
	if err != nil {
		return fmt.Errorf("create output file: %w", err)
	}
	defer f.Close() //nolint:errcheck // best effort close on error path

	funcs := template.FuncMap{
		"pascal":       toPascalCase,
		"actionSuffix": actionFuncSuffix,
	}

	tmpl := template.Must(template.New("types").Funcs(funcs).Parse(typesTemplate))
	if err := tmpl.Execute(f, model); err != nil {
		return fmt.Errorf("execute template: %w", err)
	}
	return nil
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if part != "" {
			parts[i] = string(unicode.ToUpper(rune(part[0]))) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// actionFuncSuffix returns "Action" suffix if the action name conflicts with a type name
func actionFuncSuffix(action string, types []Type) string {
	for _, t := range types {
		if t.Name == action {
			return "Action"
		}
	}
	return ""
}

const typesTemplate = `// Code generated by go generate; DO NOT EDIT.
package authz

import "github.com/google/uuid"

// ObjectType identifies the type of an object (subject or resource).
type ObjectType string

const (
{{- range .Types}}
	ObjectType{{pascal .Name}} ObjectType = "{{.Name}}"
{{- end}}
)

// ActionName identifies the operation being performed.
// These map directly to OpenFGA relations.
type ActionName string

const (
{{- range .Actions}}
	Action{{pascal .}} ActionName = "{{.}}"
{{- end}}
)

// Object represents an entity in an authorization check (subject or resource).
type Object struct {
	Type       ObjectType
	ID         string
	Properties map[string]any
}

// String formats the object as "type:id" for use in OpenFGA tuples.
func (o Object) String() string {
	return string(o.Type) + ":" + o.ID
}

// Action represents the operation being performed.
type Action struct {
	Name       ActionName
	Properties map[string]any
}

// Context provides additional environmental attributes for the evaluation.
type Context map[string]any

// EvaluationRequest represents a single access evaluation request.
type EvaluationRequest struct {
	Subject  Object
	Resource Object
	Action   Action
	Context  Context
}

// Decision represents the result of an access evaluation.
type Decision struct {
	Decision bool
	Context  Context
}

// EvaluationSemantic defines how batch evaluations are processed.
type EvaluationSemantic string

const (
	// ExecuteAll processes all requests independently (default).
	ExecuteAll EvaluationSemantic = "execute_all"
	// DenyOnFirstDeny stops processing on the first denied request.
	DenyOnFirstDeny EvaluationSemantic = "deny_on_first_deny"
	// PermitOnFirstPermit stops processing on the first permitted request.
	PermitOnFirstPermit EvaluationSemantic = "permit_on_first_permit"
)

// EvaluationsOptions configures batch evaluation behavior.
type EvaluationsOptions struct {
	Semantic EvaluationSemantic
}

// EvaluationsRequest represents a batch of access evaluation requests.
type EvaluationsRequest struct {
	// Default values applied to all evaluations
	Subject  *Object
	Resource *Object
	Action   *Action
	Context  Context

	// Individual evaluations (override defaults)
	Evaluations []EvaluationRequest
	Options     *EvaluationsOptions
}

// EvaluationsResponse contains the results of batch evaluations.
type EvaluationsResponse struct {
	Evaluations []Decision
}

// Object constructors
{{- $types := .Types}}
{{range .Types}}
// {{pascal .Name}} creates an Object of type {{.Name}}.
func {{pascal .Name}}(id uuid.UUID) Object {
	return Object{
		Type: ObjectType{{pascal .Name}},
		ID:   id.String(),
	}
}
{{end}}

// Action constructors
{{range .Actions}}
// {{pascal .}}{{actionSuffix . $types}} creates an Action for the {{.}} relation.
func {{pascal .}}{{actionSuffix . $types}}() Action {
	return Action{Name: Action{{pascal .}}}
}
{{end}}
`

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const outboxGetAndLock = `-- name: OutboxGetAndLock :one
SELECT id,
       cluster_id,
       namespace_id,
       project_member_id,
       project_id,
       event,
       source,
       status,
       retries
FROM tenant.cluster_outbox
WHERE status IN ('pending', 'retrying')
  AND (retry_after IS NULL OR retry_after <= now())
ORDER BY created ASC
LIMIT 1
FOR NO KEY UPDATE SKIP LOCKED
`

type OutboxGetAndLockRow struct {
	ID              uuid.UUID
	ClusterID       pgtype.UUID
	NamespaceID     pgtype.UUID
	ProjectMemberID pgtype.UUID
	ProjectID       pgtype.UUID
	Event           string
	Source          string
	Status          string
	Retries         int32
}

// Claims the next pending/retryable outbox row.
// Uses FOR NO KEY UPDATE SKIP LOCKED for concurrent worker safety.
func (q *Queries) OutboxGetAndLock(ctx context.Context) (OutboxGetAndLockRow, error) {
	row := q.db.QueryRow(ctx, outboxGetAndLock)
	var i OutboxGetAndLockRow
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.NamespaceID,
		&i.ProjectMemberID,
		&i.ProjectID,
		&i.Event,
		&i.Source,
		&i.Status,
		&i.Retries,
	)
	return i, err
}

const outboxMarkFailed = `-- name: OutboxMarkFailed :exec
UPDATE tenant.cluster_outbox
SET status = 'failed', failed = now(), status_info = $1
WHERE id = $2
`

type OutboxMarkFailedParams struct {
	StatusInfo pgtype.Text
	ID         uuid.UUID
}

// Marks a row as permanently failed after exceeding max retries.
func (q *Queries) OutboxMarkFailed(ctx context.Context, arg OutboxMarkFailedParams) error {
	_, err := q.db.Exec(ctx, outboxMarkFailed, arg.StatusInfo, arg.ID)
	return err
}

const outboxMarkProcessed = `-- name: OutboxMarkProcessed :exec
UPDATE tenant.cluster_outbox
SET status = 'completed', processed = now()
WHERE id = $1
`

type OutboxMarkProcessedParams struct {
	ID uuid.UUID
}

func (q *Queries) OutboxMarkProcessed(ctx context.Context, arg OutboxMarkProcessedParams) error {
	_, err := q.db.Exec(ctx, outboxMarkProcessed, arg.ID)
	return err
}

const outboxMarkRetry = `-- name: OutboxMarkRetry :one
UPDATE tenant.cluster_outbox
SET retries = retries + 1,
    retry_after = now() + LEAST(
        $1::interval * (1 << (retries + 1)),
        $2::interval
    ),
    status = 'retrying',
    status_info = $3
WHERE id = $4
RETURNING retries
`

type OutboxMarkRetryParams struct {
	BaseInterval pgtype.Interval
	MaxBackoff   pgtype.Interval
	StatusInfo   pgtype.Text
	ID           uuid.UUID
}

// Marks a row for retry with exponential backoff.
// The backoff is calculated as: base_interval * 2^(retries+1), capped at max_backoff.
// retries+1 is used because PostgreSQL evaluates expressions using the old row value,
// but we want the delay to reflect the new retry count (incremented in the same UPDATE).
func (q *Queries) OutboxMarkRetry(ctx context.Context, arg OutboxMarkRetryParams) (int32, error) {
	row := q.db.QueryRow(ctx, outboxMarkRetry,
		arg.BaseInterval,
		arg.MaxBackoff,
		arg.StatusInfo,
		arg.ID,
	)
	var retries int32
	err := row.Scan(&retries)
	return retries, err
}

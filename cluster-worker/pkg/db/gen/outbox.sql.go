// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const outboxGetAndLock = `-- name: OutboxGetAndLock :one
SELECT id, cluster_id, namespace_id, project_member_id, project_id, event, source, status, retries
FROM tenant.cluster_outbox
WHERE status IN ('pending', 'retrying')
  AND (retry_after IS NULL OR retry_after <= now())
ORDER BY id
FOR NO KEY UPDATE SKIP LOCKED
LIMIT 1
`

type OutboxGetAndLockRow struct {
	ID              uuid.UUID
	ClusterID       pgtype.UUID
	NamespaceID     pgtype.UUID
	ProjectMemberID pgtype.UUID
	ProjectID       pgtype.UUID
	Event           string
	Source          string
	Status          string
	Retries         int32
}

// Claims the next pending/retryable outbox row.
// Uses FOR NO KEY UPDATE SKIP LOCKED for concurrent worker safety.
func (q *Queries) OutboxGetAndLock(ctx context.Context) (OutboxGetAndLockRow, error) {
	row := q.db.QueryRow(ctx, outboxGetAndLock)
	var i OutboxGetAndLockRow
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.NamespaceID,
		&i.ProjectMemberID,
		&i.ProjectID,
		&i.Event,
		&i.Source,
		&i.Status,
		&i.Retries,
	)
	return i, err
}

const outboxMarkFailed = `-- name: OutboxMarkFailed :exec
UPDATE tenant.cluster_outbox
SET status = 'failed', failed = now(), status_info = $1
WHERE id = $2
`

type OutboxMarkFailedParams struct {
	StatusInfo pgtype.Text
	ID         uuid.UUID
}

// Marks a row as permanently failed after exceeding max retries.
func (q *Queries) OutboxMarkFailed(ctx context.Context, arg OutboxMarkFailedParams) error {
	_, err := q.db.Exec(ctx, outboxMarkFailed, arg.StatusInfo, arg.ID)
	return err
}

const outboxMarkProcessed = `-- name: OutboxMarkProcessed :exec
UPDATE tenant.cluster_outbox
SET status = 'completed', processed = now()
WHERE id = $1
`

type OutboxMarkProcessedParams struct {
	ID uuid.UUID
}

func (q *Queries) OutboxMarkProcessed(ctx context.Context, arg OutboxMarkProcessedParams) error {
	_, err := q.db.Exec(ctx, outboxMarkProcessed, arg.ID)
	return err
}

const outboxMarkRetry = `-- name: OutboxMarkRetry :one
UPDATE tenant.cluster_outbox
SET retries = retries + 1,
    retry_after = now() + LEAST(
        $1::interval * (1 << retries),
        $2::interval
    ),
    status = 'retrying',
    status_info = $3
WHERE id = $4
RETURNING retries
`

type OutboxMarkRetryParams struct {
	BaseInterval pgtype.Interval
	MaxBackoff   pgtype.Interval
	StatusInfo   pgtype.Text
	ID           uuid.UUID
}

// Marks a row for retry with exponential backoff.
// The backoff is calculated as: base_interval * 2^retries, capped at max_backoff.
func (q *Queries) OutboxMarkRetry(ctx context.Context, arg OutboxMarkRetryParams) (int32, error) {
	row := q.db.QueryRow(ctx, outboxMarkRetry,
		arg.BaseInterval,
		arg.MaxBackoff,
		arg.StatusInfo,
		arg.ID,
	)
	var retries int32
	err := row.Scan(&retries)
	return retries, err
}

const outboxReconcileClusters = `-- name: OutboxReconcileClusters :exec
INSERT INTO tenant.cluster_outbox (cluster_id, event, source)
SELECT tenant.clusters.id, 'reconcile', 'reconcile'
FROM tenant.clusters
LEFT JOIN tenant.cluster_outbox ON tenant.cluster_outbox.cluster_id = tenant.clusters.id
  AND tenant.cluster_outbox.status = 'completed'
  AND tenant.cluster_outbox.processed >= GREATEST(
      tenant.clusters.created,
      COALESCE(tenant.clusters.deleted, '1970-01-01')
  )
WHERE tenant.cluster_outbox.id IS NULL
`

// Insert outbox rows for clusters that have no completed outbox entry
// after their last modification.
func (q *Queries) OutboxReconcileClusters(ctx context.Context) error {
	_, err := q.db.Exec(ctx, outboxReconcileClusters)
	return err
}

const outboxReconcileNamespaces = `-- name: OutboxReconcileNamespaces :exec
INSERT INTO tenant.cluster_outbox (namespace_id, event, source)
SELECT tenant.namespaces.id, 'reconcile', 'reconcile'
FROM tenant.namespaces
LEFT JOIN tenant.cluster_outbox ON tenant.cluster_outbox.namespace_id = tenant.namespaces.id
  AND tenant.cluster_outbox.status = 'completed'
  AND tenant.cluster_outbox.processed >= GREATEST(
      tenant.namespaces.created,
      COALESCE(tenant.namespaces.deleted, '1970-01-01')
  )
WHERE tenant.cluster_outbox.id IS NULL
`

// Insert outbox rows for namespaces that have no completed outbox entry
// after their last modification.
func (q *Queries) OutboxReconcileNamespaces(ctx context.Context) error {
	_, err := q.db.Exec(ctx, outboxReconcileNamespaces)
	return err
}

const outboxReconcileProjectMembers = `-- name: OutboxReconcileProjectMembers :exec
INSERT INTO tenant.cluster_outbox (project_member_id, event, source)
SELECT tenant.project_members.id, 'reconcile', 'reconcile'
FROM tenant.project_members
LEFT JOIN tenant.cluster_outbox ON tenant.cluster_outbox.project_member_id = tenant.project_members.id
  AND tenant.cluster_outbox.status = 'completed'
  AND tenant.cluster_outbox.processed >= GREATEST(
      tenant.project_members.created,
      COALESCE(tenant.project_members.deleted, '1970-01-01')
  )
WHERE tenant.cluster_outbox.id IS NULL
`

func (q *Queries) OutboxReconcileProjectMembers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, outboxReconcileProjectMembers)
	return err
}

const outboxReconcileProjects = `-- name: OutboxReconcileProjects :exec
INSERT INTO tenant.cluster_outbox (project_id, event, source)
SELECT tenant.projects.id, 'reconcile', 'reconcile'
FROM tenant.projects
WHERE tenant.projects.deleted IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM tenant.cluster_outbox
    WHERE tenant.cluster_outbox.project_id = tenant.projects.id
      AND tenant.cluster_outbox.status = 'completed'
      AND tenant.cluster_outbox.processed >= tenant.projects.deleted
  )
`

func (q *Queries) OutboxReconcileProjects(ctx context.Context) error {
	_, err := q.db.Exec(ctx, outboxReconcileProjects)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project_member.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const projectMemberCountAdmins = `-- name: ProjectMemberCountAdmins :one
SELECT COUNT(*)::int as admin_count
FROM tenant.project_members
WHERE project_id = $1 AND role = 'admin'
`

type ProjectMemberCountAdminsParams struct {
	ProjectID uuid.UUID
}

func (q *Queries) ProjectMemberCountAdmins(ctx context.Context, arg ProjectMemberCountAdminsParams) (int32, error) {
	row := q.db.QueryRow(ctx, projectMemberCountAdmins, arg.ProjectID)
	var admin_count int32
	err := row.Scan(&admin_count)
	return admin_count, err
}

const projectMemberCreate = `-- name: ProjectMemberCreate :one
INSERT INTO tenant.project_members (project_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING id
`

type ProjectMemberCreateParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
	Role      string
}

func (q *Queries) ProjectMemberCreate(ctx context.Context, arg ProjectMemberCreateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, projectMemberCreate, arg.ProjectID, arg.UserID, arg.Role)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const projectMemberDelete = `-- name: ProjectMemberDelete :execrows
DELETE FROM tenant.project_members
WHERE id = $1
`

type ProjectMemberDeleteParams struct {
	ID uuid.UUID
}

func (q *Queries) ProjectMemberDelete(ctx context.Context, arg ProjectMemberDeleteParams) (int64, error) {
	result, err := q.db.Exec(ctx, projectMemberDelete, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const projectMemberGetByID = `-- name: ProjectMemberGetByID :one
SELECT id, project_id, user_id, role, created
FROM tenant.project_members
WHERE id = $1
`

type ProjectMemberGetByIDParams struct {
	ID uuid.UUID
}

func (q *Queries) ProjectMemberGetByID(ctx context.Context, arg ProjectMemberGetByIDParams) (TenantProjectMember, error) {
	row := q.db.QueryRow(ctx, projectMemberGetByID, arg.ID)
	var i TenantProjectMember
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.Created,
	)
	return i, err
}

const projectMemberGetByProjectAndUser = `-- name: ProjectMemberGetByProjectAndUser :one
SELECT id, project_id, user_id, role, created
FROM tenant.project_members
WHERE project_id = $1 AND user_id = $2
`

type ProjectMemberGetByProjectAndUserParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) ProjectMemberGetByProjectAndUser(ctx context.Context, arg ProjectMemberGetByProjectAndUserParams) (TenantProjectMember, error) {
	row := q.db.QueryRow(ctx, projectMemberGetByProjectAndUser, arg.ProjectID, arg.UserID)
	var i TenantProjectMember
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.Created,
	)
	return i, err
}

const projectMemberList = `-- name: ProjectMemberList :many
SELECT
    pm.id,
    pm.project_id,
    pm.user_id,
    pm.role,
    pm.created,
    u.name as user_name,
    u.external_id as user_external_id
FROM tenant.project_members pm
JOIN tenant.users u ON u.id = pm.user_id
WHERE pm.project_id = $1
ORDER BY pm.created ASC
`

type ProjectMemberListParams struct {
	ProjectID uuid.UUID
}

type ProjectMemberListRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	UserID         uuid.UUID
	Role           string
	Created        pgtype.Timestamptz
	UserName       string
	UserExternalID string
}

func (q *Queries) ProjectMemberList(ctx context.Context, arg ProjectMemberListParams) ([]ProjectMemberListRow, error) {
	rows, err := q.db.Query(ctx, projectMemberList, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectMemberListRow
	for rows.Next() {
		var i ProjectMemberListRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.Created,
			&i.UserName,
			&i.UserExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectMemberUpdateRole = `-- name: ProjectMemberUpdateRole :execrows
UPDATE tenant.project_members
SET role = $2
WHERE id = $1
`

type ProjectMemberUpdateRoleParams struct {
	ID   uuid.UUID
	Role string
}

func (q *Queries) ProjectMemberUpdateRole(ctx context.Context, arg ProjectMemberUpdateRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, projectMemberUpdateRole, arg.ID, arg.Role)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

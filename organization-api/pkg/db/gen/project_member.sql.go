// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project_member.sql

package db

import (
	"context"

	"github.com/fundament-oss/fundament/common/dbconst"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const projectMemberCreate = `-- name: ProjectMemberCreate :one
INSERT INTO tenant.project_members (project_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING id
`

type ProjectMemberCreateParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
	Role      dbconst.ProjectMemberRole
}

func (q *Queries) ProjectMemberCreate(ctx context.Context, arg ProjectMemberCreateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, projectMemberCreate, arg.ProjectID, arg.UserID, arg.Role)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const projectMemberDelete = `-- name: ProjectMemberDelete :execrows
UPDATE tenant.project_members
SET deleted = now()
WHERE id = $1
AND deleted IS NULL
`

type ProjectMemberDeleteParams struct {
	ID uuid.UUID
}

func (q *Queries) ProjectMemberDelete(ctx context.Context, arg ProjectMemberDeleteParams) (int64, error) {
	result, err := q.db.Exec(ctx, projectMemberDelete, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const projectMemberGetByID = `-- name: ProjectMemberGetByID :one
SELECT id, project_id, user_id, role
FROM tenant.project_members
WHERE id = $1
AND deleted IS NULL
`

type ProjectMemberGetByIDParams struct {
	ID uuid.UUID
}

type ProjectMemberGetByIDRow struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
	UserID    uuid.UUID
	Role      dbconst.ProjectMemberRole
}

func (q *Queries) ProjectMemberGetByID(ctx context.Context, arg ProjectMemberGetByIDParams) (ProjectMemberGetByIDRow, error) {
	row := q.db.QueryRow(ctx, projectMemberGetByID, arg.ID)
	var i ProjectMemberGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const projectMemberList = `-- name: ProjectMemberList :many
SELECT
    project_members.id,
    project_members.project_id,
    project_members.user_id,
    project_members.role,
    project_members.created,
    users.name as user_name,
    users.external_id as user_external_id
FROM tenant.project_members
INNER JOIN tenant.users
  ON users.id = project_members.user_id
WHERE project_members.project_id = $1
  AND project_members.deleted IS NULL
ORDER BY project_members.created ASC
`

type ProjectMemberListParams struct {
	ProjectID uuid.UUID
}

type ProjectMemberListRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	UserID         uuid.UUID
	Role           dbconst.ProjectMemberRole
	Created        pgtype.Timestamptz
	UserName       string
	UserExternalID pgtype.Text
}

func (q *Queries) ProjectMemberList(ctx context.Context, arg ProjectMemberListParams) ([]ProjectMemberListRow, error) {
	rows, err := q.db.Query(ctx, projectMemberList, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectMemberListRow
	for rows.Next() {
		var i ProjectMemberListRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.Created,
			&i.UserName,
			&i.UserExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectMemberUpdateRole = `-- name: ProjectMemberUpdateRole :execrows
UPDATE tenant.project_members
SET role = $2
WHERE id = $1
AND deleted IS NULL
`

type ProjectMemberUpdateRoleParams struct {
	ID   uuid.UUID
	Role dbconst.ProjectMemberRole
}

func (q *Queries) ProjectMemberUpdateRole(ctx context.Context, arg ProjectMemberUpdateRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, projectMemberUpdateRole, arg.ID, arg.Role)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

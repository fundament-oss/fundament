// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: namespace.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const namespaceCreate = `-- name: NamespaceCreate :one
INSERT INTO tenant.namespaces (project_id, cluster_id, name)
SELECT p.id, c.id, $1::text
FROM tenant.projects p
JOIN tenant.organizations o ON o.id = p.organization_id
JOIN tenant.clusters c ON c.organization_id = o.id AND c.name = $2::text AND c.deleted IS NULL
WHERE o.name = $3::text AND p.name = $4::text AND p.deleted IS NULL
RETURNING id, project_id, cluster_id, name, created
`

type NamespaceCreateParams struct {
	Name             string
	ClusterName      string
	OrganizationName string
	ProjectName      string
}

type NamespaceCreateRow struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
	ClusterID uuid.UUID
	Name      string
	Created   pgtype.Timestamptz
}

func (q *Queries) NamespaceCreate(ctx context.Context, arg NamespaceCreateParams) (NamespaceCreateRow, error) {
	row := q.db.QueryRow(ctx, namespaceCreate,
		arg.Name,
		arg.ClusterName,
		arg.OrganizationName,
		arg.ProjectName,
	)
	var i NamespaceCreateRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ClusterID,
		&i.Name,
		&i.Created,
	)
	return i, err
}

const namespaceDelete = `-- name: NamespaceDelete :execrows
UPDATE tenant.namespaces
SET deleted = now()
WHERE id = (
  SELECT n.id
  FROM tenant.namespaces n
  JOIN tenant.projects p ON p.id = n.project_id
  JOIN tenant.organizations o ON o.id = p.organization_id
  WHERE o.name = $1::text
    AND p.name = $2::text
    AND n.name = $3::text
    AND n.deleted IS NULL
    AND p.deleted IS NULL
)
`

type NamespaceDeleteParams struct {
	OrganizationName string
	ProjectName      string
	NamespaceName    string
}

func (q *Queries) NamespaceDelete(ctx context.Context, arg NamespaceDeleteParams) (int64, error) {
	result, err := q.db.Exec(ctx, namespaceDelete, arg.OrganizationName, arg.ProjectName, arg.NamespaceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const namespaceList = `-- name: NamespaceList :many
SELECT
  n.id,
  n.name,
  p.name AS project_name,
  c.name AS cluster_name,
  n.created
FROM tenant.namespaces n
JOIN tenant.projects p ON p.id = n.project_id
JOIN tenant.clusters c ON c.id = n.cluster_id
JOIN tenant.organizations o ON o.id = p.organization_id
WHERE o.name = $1::text AND n.deleted IS NULL
ORDER BY n.created DESC
`

type NamespaceListParams struct {
	OrganizationName string
}

type NamespaceListRow struct {
	ID          uuid.UUID
	Name        string
	ProjectName string
	ClusterName string
	Created     pgtype.Timestamptz
}

func (q *Queries) NamespaceList(ctx context.Context, arg NamespaceListParams) ([]NamespaceListRow, error) {
	rows, err := q.db.Query(ctx, namespaceList, arg.OrganizationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NamespaceListRow
	for rows.Next() {
		var i NamespaceListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProjectName,
			&i.ClusterName,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

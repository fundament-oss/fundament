#!/bin/bash
set -euo pipefail

SQL_FILE="../fundament.sql"
OUTPUT_FILE="../../common/dbconst/constraints.go"

if [[ ! -f "$SQL_FILE" ]]; then
  echo "Error: File '$SQL_FILE' not found."
  exit 1
fi

# Create associative array to store constraint -> table mappings
declare -A constraint_to_table

current_table=""
current_schema=""

while IFS= read -r line; do
  # Check if we're entering a new CREATE TABLE
  if [[ "$line" =~ ^CREATE[[:space:]]+TABLE[[:space:]]+([a-z_0-9]+)\.([a-z_0-9]+)[[:space:]]*\( ]]; then
    current_schema="${BASH_REMATCH[1]}"
    current_table="${BASH_REMATCH[2]}"
  fi

  # Check for CONSTRAINT name pattern (inline in CREATE TABLE)
  if [[ "$line" =~ CONSTRAINT[[:space:]]+([a-z_0-9]+)[[:space:]]+ ]]; then
    constraint="${BASH_REMATCH[1]}"
    # Skip primary key constraints (we don't need them in code)
    if [[ ! "$constraint" =~ _pk$ ]]; then
      if [[ -n "$current_table" ]]; then
        constraint_to_table["$constraint"]="$current_schema.$current_table"
      fi
    fi
  fi

  # Check for CREATE CONSTRAINT TRIGGER (standalone constraint)
  if [[ "$line" =~ ^CREATE[[:space:]]+CONSTRAINT[[:space:]]+TRIGGER[[:space:]]+([a-z_0-9]+) ]]; then
    constraint="${BASH_REMATCH[1]}"
    # These triggers reference a table on the next few lines, so we just note them with empty table for now
    constraint_to_table["$constraint"]="(constraint trigger)"
  fi

  # Check for CREATE UNIQUE INDEX (also creates a constraint-like name)
  if [[ "$line" =~ ^CREATE[[:space:]]+UNIQUE[[:space:]]+INDEX[[:space:]]+([a-z_0-9]+)[[:space:]]+ON[[:space:]]+([a-z_0-9]+\.[a-z_0-9]+) ]]; then
    constraint="${BASH_REMATCH[1]}"
    table="${BASH_REMATCH[2]}"
    constraint_to_table["$constraint"]="$table"
  fi

  # Check for ALTER TABLE ... ADD CONSTRAINT (foreign keys and other deferred constraints)
  if [[ "$line" =~ ^ALTER[[:space:]]+TABLE[[:space:]]+([a-z_0-9]+\.[a-z_0-9]+)[[:space:]]+ADD[[:space:]]+CONSTRAINT[[:space:]]+([a-z_0-9]+) ]]; then
    table="${BASH_REMATCH[1]}"
    constraint="${BASH_REMATCH[2]}"
    # Skip primary key constraints
    if [[ ! "$constraint" =~ _pk$ ]]; then
      constraint_to_table["$constraint"]="$table"
    fi
  fi
done < "$SQL_FILE"

# Convert snake_case to PascalCase
to_pascal_case() {
  echo "$1" | sed -E 's/(^|_)([a-z0-9])/\U\2/g'
}

# Create sorted output by constraint name
sorted_constraints=($(for c in "${!constraint_to_table[@]}"; do echo "$c"; done | sort))

# Generate the Go file
{
  echo "// Code generated by _generate-dbconstraints. DO NOT EDIT."
  echo ""
  echo "package dbconst"
  echo ""
  echo "const ("

  for constraint in "${sorted_constraints[@]}"; do
    table="${constraint_to_table[$constraint]}"
    const_name=$(to_pascal_case "$constraint")
    echo "	// Constraint$const_name is defined on $table."
    echo "	Constraint$const_name = \"$constraint\""
  done

  echo ")"
} > "$OUTPUT_FILE"

echo "Generated $OUTPUT_FILE with ${#sorted_constraints[@]} constraints."

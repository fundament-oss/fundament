#!/bin/bash
set -euo pipefail

SQL_FILE="../fundament.sql"
OUTPUT_FILE="../../common/dbconst/enums.go"

if [[ ! -f "$SQL_FILE" ]]; then
  echo "Error: File '$SQL_FILE' not found."
  exit 1
fi

# Associative arrays to store enum info
# Key: "TableColumn" (e.g., "ClusterStatus"), Value: space-separated list of values
declare -A enum_values
declare -A enum_tables

current_table=""
current_schema=""

while IFS= read -r line; do
  # Check if we're entering a new CREATE TABLE
  if [[ "$line" =~ ^CREATE[[:space:]]+TABLE[[:space:]]+([a-z_0-9]+)\.([a-z_0-9]+)[[:space:]]*\( ]]; then
    current_schema="${BASH_REMATCH[1]}"
    current_table="${BASH_REMATCH[2]}"
  fi

  # Check for CHECK constraint with IN clause pattern: CONSTRAINT xxx_ck_yyy CHECK (yyy IN ('a','b','c'))
  # Using grep to extract the pattern more reliably
  if echo "$line" | grep -qE 'CONSTRAINT[[:space:]]+[a-z_0-9]+_ck_([a-z_0-9]+)[[:space:]]+CHECK'; then
    # Extract column name from constraint name (e.g., clusters_ck_status -> status)
    constraint_name=$(echo "$line" | grep -oE '[a-z_0-9]+_ck_[a-z_0-9]+' | head -1)
    column="${constraint_name##*_ck_}"

    # Extract the IN values
    if echo "$line" | grep -qE 'IN[[:space:]]*\('; then
      # Extract everything between IN ( and )
      values_part=$(echo "$line" | sed -n "s/.*IN[[:space:]]*(\([^)]*\)).*/\1/p")

      if [[ -n "$values_part" && -n "$current_table" ]]; then
        # Convert table_column to PascalCase for the type name (e.g., clusters + status -> ClusterStatus)
        # Remove trailing 's' from table name for singular form
        singular_table="${current_table%s}"
        type_name=$(echo "${singular_table}_${column}" | sed -E 's/(^|_)([a-z])/\U\2/g')

        # Extract values from the IN clause (handles 'value1','value2',...)
        # Parse comma-separated quoted values
        values=""
        for val in $(echo "$values_part" | tr ',' '\n' | sed "s/[[:space:]]*'\\([^']*\\)'.*/\\1/"); do
          if [[ -n "$values" ]]; then
            values="$values $val"
          else
            values="$val"
          fi
        done

        enum_values["$type_name"]="$values"
        enum_tables["$type_name"]="$current_schema.$current_table.$column"
      fi
    fi
  fi
done < "$SQL_FILE"

# Convert snake_case to PascalCase
to_pascal_case() {
  echo "$1" | sed -E 's/(^|_)([a-z0-9])/\U\2/g'
}

# Get sorted type names
sorted_types=($(for t in "${!enum_values[@]}"; do echo "$t"; done | sort))

# Count total enum values
total_values=0
for type_name in "${!enum_values[@]}"; do
  values="${enum_values[$type_name]}"
  count=$(echo "$values" | wc -w)
  total_values=$((total_values + count))
done

# Generate the Go file
{
  echo "// Code generated by _generate-dbconst-enums. DO NOT EDIT."
  echo ""
  echo "package dbconst"

  for type_name in "${sorted_types[@]}"; do
    table="${enum_tables[$type_name]}"
    values="${enum_values[$type_name]}"

    echo ""
    echo "// $type_name represents valid values for $table."
    echo "type $type_name string"
    echo ""
    echo "const ("

    for value in $values; do
      const_value=$(to_pascal_case "$value")
      echo "	${type_name}_${const_value} $type_name = \"$value\""
    done

    echo ")"
  done
} > "$OUTPUT_FILE"

echo "Generated $OUTPUT_FILE with ${#sorted_types[@]} enum types and $total_values values."

#!/usr/bin/env bash
set -euo pipefail

SQL_FILE="../fundament.sql"
OUTPUT_FILE="../../common/dbconst/hints.go"

if [[ ! -f "$SQL_FILE" ]]; then
  echo "Error: File '$SQL_FILE' not found."
  exit 1
fi

# Create associative array to store hint -> function mappings
declare -A hint_to_function

current_function=""

while IFS= read -r line; do
  # Check if we're entering a new function
  if [[ "$line" =~ ^CREATE[[:space:]]+OR[[:space:]]+REPLACE[[:space:]]+FUNCTION[[:space:]]+([a-z_0-9]+\.[a-z_0-9]+)[[:space:]]*\( ]]; then
    current_function="${BASH_REMATCH[1]}"
  fi

  # Check for HINT = 'xxx' pattern (spaces optional around =)
  if [[ "$line" =~ HINT[[:space:]]*=[[:space:]]*\'([a-z_0-9]+)\' ]]; then
    hint="${BASH_REMATCH[1]}"
    if [[ -n "$current_function" ]]; then
      hint_to_function["$hint"]="$current_function"
    fi
  fi
done < "$SQL_FILE"

# Convert snake_case to PascalCase (portable across GNU/BSD)
to_pascal_case() {
  echo "$1" | awk -F'_' '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1' OFS=''
}

# Create sorted output by function name
# First, create an array of "function hint" pairs
pairs=()
for hint in "${!hint_to_function[@]}"; do
  func="${hint_to_function[$hint]}"
  pairs+=("$func $hint")
done

# Sort the pairs by function name (if there are any)
if [[ ${#pairs[@]} -gt 0 ]]; then
  IFS=$'\n' sorted_pairs=($(sort <<<"${pairs[*]}"))
  unset IFS
else
  sorted_pairs=()
fi

# Generate the Go file
{
  echo "// Code generated by _generate-dbconst-hints. DO NOT EDIT."
  echo ""
  echo "package dbconst"

  if [[ ${#sorted_pairs[@]} -gt 0 ]]; then
    echo ""
    echo "const ("

    for pair in "${sorted_pairs[@]}"; do
      func="${pair%% *}"
      hint="${pair#* }"
      const_name=$(to_pascal_case "$hint")
      echo "	// Hint$const_name can be thrown by $func."
      echo "	Hint$const_name = \"$hint\""
    done

    echo ")"
  fi
} > "$OUTPUT_FILE"

echo "Generated $OUTPUT_FILE with ${#sorted_pairs[@]} hints."

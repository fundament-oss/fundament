// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/fundament-oss/fundament/common/dbconst"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const aPIKeyGetByHash = `-- name: APIKeyGetByHash :one
SELECT id, organization_id, user_id, name, token_prefix, expires, revoked, last_used, created, deleted
FROM authn.api_key_get_by_hash($1)
`

type APIKeyGetByHashParams struct {
	PTokenHash []byte
}

type APIKeyGetByHashRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Name           string
	TokenPrefix    string
	Expires        pgtype.Timestamptz
	Revoked        pgtype.Timestamptz
	LastUsed       pgtype.Timestamptz
	Created        pgtype.Timestamptz
	Deleted        pgtype.Timestamptz
}

// Uses SECURITY DEFINER function to bypass RLS (we don't know org_id before lookup)
func (q *Queries) APIKeyGetByHash(ctx context.Context, arg APIKeyGetByHashParams) (APIKeyGetByHashRow, error) {
	row := q.db.QueryRow(ctx, aPIKeyGetByHash, arg.PTokenHash)
	var i APIKeyGetByHashRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Name,
		&i.TokenPrefix,
		&i.Expires,
		&i.Revoked,
		&i.LastUsed,
		&i.Created,
		&i.Deleted,
	)
	return i, err
}

const organizationCreate = `-- name: OrganizationCreate :one
INSERT INTO tenant.organizations (name)
VALUES ($1)
RETURNING id, name, created
`

type OrganizationCreateParams struct {
	Name string
}

type OrganizationCreateRow struct {
	ID      uuid.UUID
	Name    string
	Created pgtype.Timestamptz
}

func (q *Queries) OrganizationCreate(ctx context.Context, arg OrganizationCreateParams) (OrganizationCreateRow, error) {
	row := q.db.QueryRow(ctx, organizationCreate, arg.Name)
	var i OrganizationCreateRow
	err := row.Scan(&i.ID, &i.Name, &i.Created)
	return i, err
}

const organizationUserAccept = `-- name: OrganizationUserAccept :exec
UPDATE tenant.organizations_users
SET status = 'accepted'
WHERE user_id = $1
    AND status = 'pending'
    AND deleted IS NULL
`

type OrganizationUserAcceptParams struct {
	UserID uuid.UUID
}

// Transitions a pending invitation to accepted when an invited user logs in
func (q *Queries) OrganizationUserAccept(ctx context.Context, arg OrganizationUserAcceptParams) error {
	_, err := q.db.Exec(ctx, organizationUserAccept, arg.UserID)
	return err
}

const organizationUserCreate = `-- name: OrganizationUserCreate :one
INSERT INTO tenant.organizations_users (organization_id, user_id, permission, status)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, user_id, permission, status, created
`

type OrganizationUserCreateParams struct {
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Permission     dbconst.OrganizationsUserPermission
	Status         dbconst.OrganizationsUserStatus
}

type OrganizationUserCreateRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Permission     dbconst.OrganizationsUserPermission
	Status         dbconst.OrganizationsUserStatus
	Created        pgtype.Timestamptz
}

// Creates a membership for a user in an organization
func (q *Queries) OrganizationUserCreate(ctx context.Context, arg OrganizationUserCreateParams) (OrganizationUserCreateRow, error) {
	row := q.db.QueryRow(ctx, organizationUserCreate,
		arg.OrganizationID,
		arg.UserID,
		arg.Permission,
		arg.Status,
	)
	var i OrganizationUserCreateRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Permission,
		&i.Status,
		&i.Created,
	)
	return i, err
}

const userCreate = `-- name: UserCreate :one
INSERT INTO tenant.users (name, external_ref, email)
VALUES ($1, $2, $3)
RETURNING id, name, external_ref, email, created
`

type UserCreateParams struct {
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
}

type UserCreateRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (UserCreateRow, error) {
	row := q.db.QueryRow(ctx, userCreate, arg.Name, arg.ExternalRef, arg.Email)
	var i UserCreateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

const userGetByEmail = `-- name: UserGetByEmail :one
SELECT id, name, external_ref, email, created
FROM tenant.users
WHERE email = $1 AND external_ref IS NULL AND deleted IS NULL
LIMIT 1
`

type UserGetByEmailParams struct {
	Email pgtype.Text
}

type UserGetByEmailRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

// Get a user by email who has no external_ref (pending invitation)
func (q *Queries) UserGetByEmail(ctx context.Context, arg UserGetByEmailParams) (UserGetByEmailRow, error) {
	row := q.db.QueryRow(ctx, userGetByEmail, arg.Email)
	var i UserGetByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

const userGetByExternalRef = `-- name: UserGetByExternalRef :one
SELECT id, name, external_ref, email, created
FROM tenant.users
WHERE external_ref = $1 AND deleted IS NULL
`

type UserGetByExternalRefParams struct {
	ExternalRef pgtype.Text
}

type UserGetByExternalRefRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

func (q *Queries) UserGetByExternalRef(ctx context.Context, arg UserGetByExternalRefParams) (UserGetByExternalRefRow, error) {
	row := q.db.QueryRow(ctx, userGetByExternalRef, arg.ExternalRef)
	var i UserGetByExternalRefRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

const userGetByID = `-- name: UserGetByID :one
SELECT id, name, external_ref, email, created
FROM tenant.users
WHERE id = $1 AND deleted IS NULL
`

type UserGetByIDParams struct {
	ID uuid.UUID
}

type UserGetByIDRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

func (q *Queries) UserGetByID(ctx context.Context, arg UserGetByIDParams) (UserGetByIDRow, error) {
	row := q.db.QueryRow(ctx, userGetByID, arg.ID)
	var i UserGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

const userListOrganizations = `-- name: UserListOrganizations :many
SELECT
    organizations_users.organization_id,
    organizations_users.permission,
    organizations_users.status
FROM tenant.organizations_users
WHERE organizations_users.user_id = $1
    AND organizations_users.status = 'accepted'
    AND organizations_users.deleted IS NULL
ORDER BY organizations_users.created ASC
`

type UserListOrganizationsParams struct {
	UserID uuid.UUID
}

type UserListOrganizationsRow struct {
	OrganizationID uuid.UUID
	Permission     dbconst.OrganizationsUserPermission
	Status         dbconst.OrganizationsUserStatus
}

// Get the organizations a user belongs to (only accepted memberships)
func (q *Queries) UserListOrganizations(ctx context.Context, arg UserListOrganizationsParams) ([]UserListOrganizationsRow, error) {
	rows, err := q.db.Query(ctx, userListOrganizations, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserListOrganizationsRow
	for rows.Next() {
		var i UserListOrganizationsRow
		if err := rows.Scan(&i.OrganizationID, &i.Permission, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userSetExternalRef = `-- name: UserSetExternalRef :exec
UPDATE tenant.users SET external_ref = $2, name = $3 WHERE id = $1
`

type UserSetExternalRefParams struct {
	ID          uuid.UUID
	ExternalRef pgtype.Text
	Name        string
}

func (q *Queries) UserSetExternalRef(ctx context.Context, arg UserSetExternalRefParams) error {
	_, err := q.db.Exec(ctx, userSetExternalRef, arg.ID, arg.ExternalRef, arg.Name)
	return err
}

const userUpdate = `-- name: UserUpdate :one
UPDATE tenant.users
SET name = $2
WHERE external_ref = $1
RETURNING id, name, external_ref, email, created
`

type UserUpdateParams struct {
	ExternalRef pgtype.Text
	Name        string
}

type UserUpdateRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

func (q *Queries) UserUpdate(ctx context.Context, arg UserUpdateParams) (UserUpdateRow, error) {
	row := q.db.QueryRow(ctx, userUpdate, arg.ExternalRef, arg.Name)
	var i UserUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

const userUpsert = `-- name: UserUpsert :one
INSERT INTO tenant.users (name, external_ref, email)
VALUES ($1, $2, $3)
ON CONFLICT (external_ref) WHERE deleted IS NULL
DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email
RETURNING id, name, external_ref, email, created
`

type UserUpsertParams struct {
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
}

type UserUpsertRow struct {
	ID          uuid.UUID
	Name        string
	ExternalRef pgtype.Text
	Email       pgtype.Text
	Created     pgtype.Timestamptz
}

func (q *Queries) UserUpsert(ctx context.Context, arg UserUpsertParams) (UserUpsertRow, error) {
	row := q.db.QueryRow(ctx, userUpsert, arg.Name, arg.ExternalRef, arg.Email)
	var i UserUpsertRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ExternalRef,
		&i.Email,
		&i.Created,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/fundament-oss/fundament/common/dbconst"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAndLockNextOutboxRow = `-- name: GetAndLockNextOutboxRow :one
SELECT
    id,
    project_id,
    project_member_id,
    cluster_id,
    node_pool_id,
    namespace_id,
    api_key_id,
    install_id,
    organization_user_id,
    created,
    retries
FROM authz.outbox
WHERE status IN ('pending', 'retrying')
  AND (retry_after IS NULL OR retry_after <= now())
ORDER BY created ASC
LIMIT 1
FOR NO KEY UPDATE SKIP LOCKED
`

type GetAndLockNextOutboxRowRow struct {
	ID                 uuid.UUID
	ProjectID          pgtype.UUID
	ProjectMemberID    pgtype.UUID
	ClusterID          pgtype.UUID
	NodePoolID         pgtype.UUID
	NamespaceID        pgtype.UUID
	ApiKeyID           pgtype.UUID
	InstallID          pgtype.UUID
	OrganizationUserID pgtype.UUID
	Created            pgtype.Timestamptz
	Retries            int32
}

// Fetches the next unprocessed outbox row, skipping rows scheduled for later retry
// or that have permanently failed.
func (q *Queries) GetAndLockNextOutboxRow(ctx context.Context) (GetAndLockNextOutboxRowRow, error) {
	row := q.db.QueryRow(ctx, getAndLockNextOutboxRow)
	var i GetAndLockNextOutboxRowRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ProjectMemberID,
		&i.ClusterID,
		&i.NodePoolID,
		&i.NamespaceID,
		&i.ApiKeyID,
		&i.InstallID,
		&i.OrganizationUserID,
		&i.Created,
		&i.Retries,
	)
	return i, err
}

const getApiKeyByID = `-- name: GetApiKeyByID :one
SELECT id, organization_id, user_id, expires, revoked, deleted
FROM authn.api_keys
WHERE id = $1
`

type GetApiKeyByIDParams struct {
	ID uuid.UUID
}

type GetApiKeyByIDRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Expires        pgtype.Timestamptz
	Revoked        pgtype.Timestamptz
	Deleted        pgtype.Timestamptz
}

func (q *Queries) GetApiKeyByID(ctx context.Context, arg GetApiKeyByIDParams) (GetApiKeyByIDRow, error) {
	row := q.db.QueryRow(ctx, getApiKeyByID, arg.ID)
	var i GetApiKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Expires,
		&i.Revoked,
		&i.Deleted,
	)
	return i, err
}

const getClusterByID = `-- name: GetClusterByID :one
SELECT id, organization_id, deleted
FROM tenant.clusters
WHERE id = $1
`

type GetClusterByIDParams struct {
	ID uuid.UUID
}

type GetClusterByIDRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Deleted        pgtype.Timestamptz
}

func (q *Queries) GetClusterByID(ctx context.Context, arg GetClusterByIDParams) (GetClusterByIDRow, error) {
	row := q.db.QueryRow(ctx, getClusterByID, arg.ID)
	var i GetClusterByIDRow
	err := row.Scan(&i.ID, &i.OrganizationID, &i.Deleted)
	return i, err
}

const getInstallByID = `-- name: GetInstallByID :one
SELECT id, cluster_id, deleted
FROM appstore.installs
WHERE id = $1
`

type GetInstallByIDParams struct {
	ID uuid.UUID
}

type GetInstallByIDRow struct {
	ID        uuid.UUID
	ClusterID uuid.UUID
	Deleted   pgtype.Timestamptz
}

func (q *Queries) GetInstallByID(ctx context.Context, arg GetInstallByIDParams) (GetInstallByIDRow, error) {
	row := q.db.QueryRow(ctx, getInstallByID, arg.ID)
	var i GetInstallByIDRow
	err := row.Scan(&i.ID, &i.ClusterID, &i.Deleted)
	return i, err
}

const getNamespaceByID = `-- name: GetNamespaceByID :one
SELECT id, project_id, cluster_id, deleted
FROM tenant.namespaces
WHERE id = $1
`

type GetNamespaceByIDParams struct {
	ID uuid.UUID
}

type GetNamespaceByIDRow struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
	ClusterID uuid.UUID
	Deleted   pgtype.Timestamptz
}

func (q *Queries) GetNamespaceByID(ctx context.Context, arg GetNamespaceByIDParams) (GetNamespaceByIDRow, error) {
	row := q.db.QueryRow(ctx, getNamespaceByID, arg.ID)
	var i GetNamespaceByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ClusterID,
		&i.Deleted,
	)
	return i, err
}

const getNodePoolByID = `-- name: GetNodePoolByID :one
SELECT id, cluster_id, deleted
FROM tenant.node_pools
WHERE id = $1
`

type GetNodePoolByIDParams struct {
	ID uuid.UUID
}

type GetNodePoolByIDRow struct {
	ID        uuid.UUID
	ClusterID uuid.UUID
	Deleted   pgtype.Timestamptz
}

func (q *Queries) GetNodePoolByID(ctx context.Context, arg GetNodePoolByIDParams) (GetNodePoolByIDRow, error) {
	row := q.db.QueryRow(ctx, getNodePoolByID, arg.ID)
	var i GetNodePoolByIDRow
	err := row.Scan(&i.ID, &i.ClusterID, &i.Deleted)
	return i, err
}

const getOrganizationUserByID = `-- name: GetOrganizationUserByID :one
SELECT id, organization_id, user_id, role, status, deleted
FROM tenant.organizations_users
WHERE id = $1
`

type GetOrganizationUserByIDParams struct {
	ID uuid.UUID
}

type GetOrganizationUserByIDRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Role           dbconst.OrganizationsUserRole
	Status         dbconst.OrganizationsUserStatus
	Deleted        pgtype.Timestamptz
}

func (q *Queries) GetOrganizationUserByID(ctx context.Context, arg GetOrganizationUserByIDParams) (GetOrganizationUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrganizationUserByID, arg.ID)
	var i GetOrganizationUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.Deleted,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, organization_id, deleted
FROM tenant.projects
WHERE id = $1
`

type GetProjectByIDParams struct {
	ID uuid.UUID
}

type GetProjectByIDRow struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Deleted        pgtype.Timestamptz
}

func (q *Queries) GetProjectByID(ctx context.Context, arg GetProjectByIDParams) (GetProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectByID, arg.ID)
	var i GetProjectByIDRow
	err := row.Scan(&i.ID, &i.OrganizationID, &i.Deleted)
	return i, err
}

const getProjectMemberByID = `-- name: GetProjectMemberByID :one
SELECT id, project_id, user_id, role, deleted
FROM tenant.project_members
WHERE id = $1
`

type GetProjectMemberByIDParams struct {
	ID uuid.UUID
}

type GetProjectMemberByIDRow struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
	UserID    uuid.UUID
	Role      dbconst.ProjectMemberRole
	Deleted   pgtype.Timestamptz
}

func (q *Queries) GetProjectMemberByID(ctx context.Context, arg GetProjectMemberByIDParams) (GetProjectMemberByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectMemberByID, arg.ID)
	var i GetProjectMemberByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.Deleted,
	)
	return i, err
}

const markOutboxRowFailed = `-- name: MarkOutboxRowFailed :exec
UPDATE authz.outbox
SET status = 'failed',
    status_info = $1
WHERE id = $2
`

type MarkOutboxRowFailedParams struct {
	StatusInfo pgtype.Text
	ID         uuid.UUID
}

// Marks a row as permanently failed after exceeding max retries.
func (q *Queries) MarkOutboxRowFailed(ctx context.Context, arg MarkOutboxRowFailedParams) error {
	_, err := q.db.Exec(ctx, markOutboxRowFailed, arg.StatusInfo, arg.ID)
	return err
}

const markOutboxRowProcessed = `-- name: MarkOutboxRowProcessed :exec
UPDATE authz.outbox
SET processed = now(),
    status = 'completed',
    status_info = NULL
WHERE id = $1
`

type MarkOutboxRowProcessedParams struct {
	ID uuid.UUID
}

func (q *Queries) MarkOutboxRowProcessed(ctx context.Context, arg MarkOutboxRowProcessedParams) error {
	_, err := q.db.Exec(ctx, markOutboxRowProcessed, arg.ID)
	return err
}

const markOutboxRowRetry = `-- name: MarkOutboxRowRetry :one
UPDATE authz.outbox
SET retries = retries + 1,
    failed = now(),
    retry_after = now() + LEAST(
        $1::interval * (1 << retries),
        $2::interval
    ),
    status = 'retrying',
    status_info = $3
WHERE id = $4
RETURNING retries
`

type MarkOutboxRowRetryParams struct {
	BaseInterval pgtype.Interval
	MaxBackoff   pgtype.Interval
	StatusInfo   pgtype.Text
	ID           uuid.UUID
}

// Marks a row for retry with exponential backoff.
// The backoff is calculated as: base_interval * 2^retries, capped at max_backoff.
func (q *Queries) MarkOutboxRowRetry(ctx context.Context, arg MarkOutboxRowRetryParams) (int32, error) {
	row := q.db.QueryRow(ctx, markOutboxRowRetry,
		arg.BaseInterval,
		arg.MaxBackoff,
		arg.StatusInfo,
		arg.ID,
	)
	var retries int32
	err := row.Scan(&retries)
	return retries, err
}
